<!DOCTYPE html>
<html>
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Papaya HUANG</title>
  <!-- add alifont -->

  <link
    rel="stylesheet"
    type="text/css"
    href="https://at.alicdn.com/t/c/font_2719161_qrg05vxlp7.css"
  />
  <!-- add style -->
  
<link rel="stylesheet" href="/css/style.css">

  <!-- add font-->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100&display=swap"
    rel="stylesheet"
  />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400&display=swap"
    rel="stylesheet"
  />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200;300;400;500;600&display=swap"
    rel="stylesheet"
  />
<meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


  <body>
    <header>
  <ul class="navbar">
    <li>
      <a href="/">
        <i class="icon iconfont icon-xuanzhongshangcheng"></i>
      </a>
    </li>
    <li>
      <a href="/about">
        <i class="icon iconfont icon-about"></i>
      </a>
    </li>
    <li>
      <a href="/projects">
        <i class="icon iconfont icon-project"></i>
      </a>
    </li>
    <li>
      <a href="/categories">
        <i class="icon iconfont icon-case-file-full"></i>
      </a>
    </li>
    <li>
      <a href="/archives">
        <i class="icon iconfont icon-Artboard2"></i>
      </a>
    </li>
  </ul>
</header>

    <aside>
  <div class="menu">
    

    <a class="menu-item" href="/">Home</a>

    

    <a class="menu-item" href="/about">About</a>

    

    <a class="menu-item" href="/projects">Projects</a>

    

    <a class="menu-item" href="/categories">Categories</a>

    

    <a class="menu-item" href="/archives">Archives</a>

    
  
  </div>
</aside>


    <div class="main"><div class="blog-post">
  
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">哲学家就餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">哲学家就餐问题的挑战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E7%BB%93%E4%B8%8E-JS-%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E"><span class="toc-text">死结与 JS 的单线程阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E7%BB%93"><span class="toc-text">解决死结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-JS"><span class="toc-text">异步 JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E6%9C%8D%E5%8A%A1%E7%94%9F%E2%80%9D%E5%92%8C%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2"><span class="toc-text">“服务生”和事件轮询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-text">ES6 任务队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol>
  <div class='blog-main'>

    <!-- title -->
    <h2 class="blog-post-title">
      <a href="/2022/11/10/从动画《万神殿》到JS运行时环境/">
        从动画《万神殿》到JS运行时环境
      </a>
    </h2>
  
    <!-- date and author -->
    <p class="blog-post-meta">
      2022-11-10 
    </p>
  
  
    <!-- content -->
    <div class="post-content">
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在动画片<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/34990593/">《万神殿》</a>第一季第一集里出现了一个并发相关的小话题，就是著名的在<em>哲学家就餐</em>问题。虽然 JS 是一个单线程语言，看似好像跟 <em>并发</em> 没有任何关联，但是仔细对比一下，好像又并不是完全没有联系。</p>
<h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>在第一集中，Caspian 一家三口正在吃晚餐，爸爸考了 Caspian 一个问题，问题具体如下：假设有 5 个哲学家在一个原型饭桌上，桌上有五碗饭，但是只有四根筷子，每一根筷子位于两个饭碗之间。假设哲学家有无限的食欲和饭也是无限供应，不在思考的时候他们就需要用一对筷子（两根）就餐，并且这两根筷子一定是自己面前饭碗左右两边的，不吃饭的时候，就放下筷子思考。如何设计一套规则，让所有的哲学家都可以在思考或者吃饭的两个状态下无限交替下去。</p>
<h3 id="哲学家就餐问题的挑战"><a href="#哲学家就餐问题的挑战" class="headerlink" title="哲学家就餐问题的挑战"></a>哲学家就餐问题的挑战</h3><p>这个问题的挑战就是避免<em>死结</em>（deadlock），死结施救一个程序无法继续执行的状态。<br>假设所有哲学家都拿起自己左手边的筷子，然后等待右手边的筷子，这就进入了死结状态，因为所有的哲学家都在等待右边的哲学家放下左手的筷子。</p>
<h2 id="死结与-JS-的单线程阻塞"><a href="#死结与-JS-的单线程阻塞" class="headerlink" title="死结与 JS 的单线程阻塞"></a>死结与 JS 的单线程阻塞</h2><p>这样停下来是不是很像在 JS 的调用栈（call stack）中出现一个需要下载的大型图片，或者一个网络请求？<br>请看以下代码：</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> processImage <span class="token operator">=</span> <span class="token punctuation">(</span>image<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'image processed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> networkRequest <span class="token operator">=</span> <span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> someData<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">processImage</span><span class="token punctuation">(</span>logo<span class="token punctuation">.</span>jpg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">networkRequest</span><span class="token punctuation">(</span>someURL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然打印<code>Hello World</code>本身很快，但是<code>greeting</code>需要等待其他两个函数调用完毕，推出调用栈之后才能执行，这里就出现了调用栈<em>阻塞</em>，虽然问题不如并发的死结这么严重，但是都影响了程序的运行。</p>
<h2 id="解决死结"><a href="#解决死结" class="headerlink" title="解决死结"></a>解决死结</h2><p>解决哲学家就餐问题有很多方法，其中一个就是<em>引入服务生</em>。也就是说当一位哲学家想要使用筷子的时候，必须先询问服务生，因为服务生知道哪只筷子正在使用，这样就可以避免死结。</p>
<p>举一个例子：<br>假设哲学家依次编号为 A 到 E，如果 A 和 C 正在吃东西，就有四根筷子正在使用，B 坐在 A 和 C 之间，所有他没有筷子可以用，D 和 E 之间有一根空余的筷子，如果 D 想吃东西，拿起第五根筷子，就会产生死结。当他征求服务生同意时，服务生就会让他等待。这样就能保证当下有两根空余的筷子，一定就有一位这虚假可以成功得到一对筷子，避免死结。</p>
<h2 id="异步-JS"><a href="#异步-JS" class="headerlink" title="异步 JS"></a>异步 JS</h2><p>如何解决上面代码块的阻塞问题呢？可以采用 <em>异步回调</em> 。</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> networkRequest <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Async Code'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">networkRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'The End'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码块的执行（也就是运行时），涉及到这样几个概念：</p>
<ul>
<li>调用栈（单线程 JS 也存在）</li>
<li>Web API（这里就是 setTimeout）</li>
<li>消息队列</li>
</ul>
<p>而上述代码快在执行的过程中：</p>
<ol>
<li>首先在<strong>调用栈</strong>中会推入<code>console.log(&quot;Hello World&quot;)</code>，执行完毕后弹出调用栈；</li>
<li><code>networkRequest()</code>会推入<strong>调用栈</strong>，然后<code>setTimeout</code>被调用，它包含了两个参数： 一个回调和一个以毫秒为单位的时间；</li>
<li><code>setTimeout()</code>在<strong>Web API</strong>环境中启动一个 2s 的的计时器，这时<code>setTimeout</code>完成，弹出调用栈；</li>
<li><code>console.log(&quot;The End&quot;)</code>推入<strong>调用栈</strong>，完成后弹出;</li>
<li>计时器过期，回调函数被推入到<strong>消息队列</strong>，但是回调不会立即执行。此时“服务生”就出场了。</li>
</ol>
<h3 id="“服务生”和事件轮询"><a href="#“服务生”和事件轮询" class="headerlink" title="“服务生”和事件轮询"></a>“服务生”和事件轮询</h3><p><strong>事件轮询</strong>的工作就是监听调用栈，确定调用栈是否为空，如果为空就检查消息队列，看看是和否有怪气的回调等待执行。</p>
<p>在我们上面的例子中，调用栈为空，有一个待执行的回调，所以<strong>事件轮询</strong>就将回调推入调用栈顶部，并执行。</p>
<p>所以上述代码块最终的输出结果为：</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//"Hello World""</span>
<span class="token comment" spellcheck="true">//"The End"</span>
<span class="token comment" spellcheck="true">//"Async Code"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这么看来，事件轮询是不是就非常像处理并发问题的服务生？</p>
<h2 id="ES6-任务队列"><a href="#ES6-任务队列" class="headerlink" title="ES6 任务队列"></a>ES6 任务队列</h2><p>ES6 中引入了任务队列，供<code>promise</code>使用，任务队列的优先级高于消息队列。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题 - 维基百科</a></p>

    </div>
  
    <hr>
    
    
       <!-- categories -->
    
       
    <span class="post-categories">
      <i class='icon iconfont icon-icon-goodscategory'></i>
      <a href="/categories/基础知识盘点/">基础知识盘点</a>
    </span>
    
    
       <!-- tag -->
     
    
    <span class="post-tags">
      <i class="icon iconfont icon-tag"></i>
      <a href="/tags/js/">js</a>
    </span>
    
  </div>
</div>


</div>
  
  </body>
</html>
